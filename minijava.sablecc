/****************************************************************
 * Dupla:                                                       *
 * Gabriel Ferreira Guilhoto - NUSP: 4404279                    *
 * Renato Cordeiro Ferreira  - NUSP: 7990933                    *
 ****************************************************************/

Package
  minijava;

Helpers
  unicode_input_character = [0..0xffff];
  ht                      = 0x0009; // horizontal tab
  lf                      = 0x000a; // line feed or newline
  ff                      = 0x000c; // form feed, or page break
  cr                      = 0x000d; // carriage return
  sp                      = ' ';    // space
  line_terminator         = lf | cr | cr lf;
  input_character         = [unicode_input_character - [cr + lf]];
  not_star                = [input_character - '*'] | line_terminator;
  not_star_not_slash      = [input_character - ['*' + '/']] | line_terminator;
  digit                   = ['0'..'9'];
  letter                  = ['a'..'z'] | ['A'..'Z'];

Tokens
  // KEYWORDS
  class_token             = 'class';
  public                  = 'public';
  static                  = 'static';
  void                    = 'void';
  main                    = 'main';
  extends                 = 'extends';
  if                      = 'if';
  else                    = 'else';
  while                   = 'while';
  this                    = 'this';
  super                   = 'super';
  new                     = 'new';
  print                   = 'System.out.println';
  int                     = 'int';
  boolean                 = 'boolean';
  string                  = 'String';
  return                  = 'return';

  // BRACES
  lparen                  = '(';
  rparen                  = ')';
  lbrace                  = '{';
  rbrace                  = '}';
  lbracket                = '[';
  rbracket                = ']';

  // OPERATORS
  plus                    = '+';
  minus                   = '-';
  mult                    = '*';
  and                     = '&&';
  not                     = '!';
  less                    = '<';
  length                  = 'length';

  // OTHERS
  assign                  = '=';
  semicolon               = ';';
  comma                   = ',';
  dot                     = '.';

  // LITERALS
  integer_literal         = (digit)+;
  true                    = 'true';
  false                   = 'false';
  identifier              = letter (letter | digit | '_')*;

  // WS
  white_space             = (ht | ff | sp | line_terminator);
  comment                 = ( ('//' input_character* line_terminator)
                            | ('/*' (not_star)* ('*' | not_star_not_slash (not_star)*)* '*/') );

Ignored Tokens
  white_space, comment;

Productions
  goal {-> program}
  =                  main_class [classes]:class_declaration_list
                     {-> New program(main_class.main_class, [classes.class_decl])};

  main_class {-> main_class}
  =                  class_token [name]:identifier [external_lbrace]:lbrace public static void main lparen string lbracket rbracket [method_parameter]:identifier rparen lbrace [statement]:statement rbrace [external_rbrace]:rbrace
                     {-> New main_class(New id(name), New id(method_parameter), statement.statement)};

  class_declaration_list {-> class_decl*}
  =   {empty}        {-> []}
  |                  class_declaration [rest]:class_declaration_list
                     {-> [class_declaration.class_decl, rest.class_decl]};

  class_declaration {-> class_decl}
  =   {extended}    class_token [name]:identifier extends [parent]:identifier lbrace [vars]:var_declaration_list [methods]:method_declaration_list rbrace
                    {-> New class_decl.extends(New id(name), New id(parent), [vars.variable_declaration], [methods.method_declaration])}
  |   {simple}      class_token [name]:identifier lbrace [vars]:var_declaration_list [methods]:method_declaration_list rbrace
                    {-> New class_decl.simple(New id(name), [vars.variable_declaration], [methods.method_declaration])};

  var_declaration_list {-> variable_declaration*}
  =   {empty}        {-> []}
  |                  [rest]:var_declaration_list var_declaration
                     {-> [rest.variable_declaration, var_declaration.variable_declaration]};

  var_declaration {-> variable_declaration}
  =                  type [name]:identifier semicolon
                     {-> New variable_declaration(type.type, New id(name))};

  method_declaration_list {-> method_declaration*}
  =   {empty}        {-> []}
  |                  [rest]:method_declaration_list method_declaration
                     {-> [rest.method_declaration, method_declaration.method_declaration]};

  method_declaration {-> method_declaration}
  =                  public [return_type]:type [name]:identifier lparen [args]:argument_list rparen lbrace [vars]:var_declaration_list [statements]:statement_list return [return_expression]:boolean_expression semicolon rbrace
                     {-> New method_declaration(return_type.type, New id(name), [args.formal_parameter], [vars.variable_declaration], [statements.statement], return_expression.expression)};

  argument_list {-> formal_parameter*}
  =   {empty}        {-> []}
  |                  type [name]:identifier [rest]:argument_list_tail
                     {-> [New formal_parameter(type.type, New id(name)), rest.formal_parameter]};

  argument_list_tail  {-> formal_parameter*}
  =   {empty}        {-> []}
  |                  comma type [name]:identifier [rest]:argument_list_tail
                     {-> [New formal_parameter(type.type, New id(name)), rest.formal_parameter]};

  type {-> type}
  =   {int}          [name]:int
                     { -> New type.int(name) }
  |   {int_array}    [name]:int lbracket rbracket
                     { -> New type.int(name) }
  |   {boolean}      [name]:boolean
                     { -> New type.boolean(name) }
  |   {identifier}   [name]:identifier
                     { -> New type.identifier(New id(name)) };

  statement_list {-> statement*}
  =   {empty}        {-> []}
  |                  statement [rest]:statement_list
                     {-> [statement.statement, rest.statement]};

  statement {-> statement}
  =   {block}            lbrace [statements]:statement_list rbrace
                         { -> New statement.block([statements.statement]) }
  |   {if}               if lparen [condition]:boolean_expression rparen [true_statement]:statement else [false_statement]:statement
                         { -> New statement.if(condition.expression, true_statement.statement, false_statement.statement) }
  |   {while}            while lparen [condition]:boolean_expression rparen [statement]:statement
                         { -> New statement.while(condition.expression, statement.statement) }
  |   {println}          print lparen [value]:boolean_expression rparen semicolon
                         { -> New statement.println(value.expression) }
  |   {assign}           [name]:identifier assign [value]:boolean_expression semicolon
                         { -> New statement.assign(New id(name), value.expression) }
  |   {array_assign}     [name]:identifier lbracket [index]:expression rbracket assign [value]:boolean_expression semicolon
                         { -> New statement.array_assign(New id(name), index.expression, value.expression) };

  boolean_expression {-> expression}
  =   {and}              [lhs]:boolean_term and [rhs]:boolean_expression
                         { -> New expression.and(lhs.expression, rhs.expression) }
  |   {boolean_term}     boolean_term
                         { -> boolean_term.expression };

  boolean_term {-> expression}
  =   {not}              not boolean_term
                         { -> New expression.not(boolean_term.expression) }
  |   {relation}         boolean_factor
                         { -> boolean_factor.expression };

  boolean_factor {-> expression}
  =   {less}             [lhs]:expression less [rhs]:boolean_factor
                         { -> New expression.less_than(lhs.expression, rhs.expression) }
  |   {expression}       expression
                         { -> expression.expression };

  expression {-> expression}
  =   {plus}             [lhs]:term plus [rhs]:expression
                         { -> New expression.plus(lhs.expression, rhs.expression) }
  |   {minus}            [lhs]:term minus [rhs]:expression
                         { -> New expression.minus(lhs.expression, rhs.expression) }
  |   {term}             term
                         { -> term.expression };

  term {-> expression}
  =   {times}            [lhs]:factor mult [rhs]:term
                         { -> New expression.times(lhs.expression, rhs.expression) }
  |   {factor}           factor
                         { -> factor.expression }
  |   {neg_factor}       minus factor
                         { -> New expression.negative(factor.expression) };

  factor {-> expression}
  =   {array_lookup}     [array]:factor lbracket [index]:expression rbracket
                         { -> New expression.array_lookup(array.expression, index.expression) }
  |   {array_length}     [array]:factor dot length
                         { -> New expression.array_length(array.expression) }
  |   {call}             [instance]:factor dot [name]:identifier lparen [actuals]:arg_list rparen
                         { -> New expression.call(instance.expression, New id(name), [actuals.expression]) }
  |   {integer}          [value]:integer_literal
                         { -> New expression.integer(value) }
  |   {true}             true
                         { -> New expression.true(true)}
  |   {false}            false
                         { -> New expression.false(false)}
  |   {identifier}       [name]:identifier
                         { -> New expression.identifier(New id(name)) }
  |   {this}             this
                         { -> New expression.this(this) }
  |   {new_array}        new int lbracket [size]:expression rbracket
                         { -> New expression.new_array(size.expression) }
  |   {new_object}       new [class_name]:identifier lparen rparen
                         { -> New expression.new_object(New id(class_name)) }
  |   {parenthesis}      lparen boolean_expression rparen
                         { -> boolean_expression.expression };

  arg_list {-> expression*}
  =   {empty}        {-> []}
  |                  boolean_expression [rest]:arg_list_tail
                     {-> [boolean_expression.expression, rest.expression]};

  arg_list_tail {-> expression*}
  =   {empty}        {-> []}
  |                  comma boolean_expression [rest]:arg_list_tail
                     {-> [boolean_expression.expression, rest.expression]};

Abstract Syntax Tree

  program =
    [main_class]:main_class
    [class_decl]:class_decl*;

  main_class =
    [name]:id
    [method_parameter]:id
    [statement]:statement;

  class_decl =
    {extends}
      [name]:id
      [parent]:id
      [variables]:variable_declaration*
      [methods]:method_declaration* |
    {simple}
      [name]:id
      [variables]:variable_declaration*
      [methods]:method_declaration*;

  method_declaration =
    [return_type]:type
    [name]:id
    [formals]:formal_parameter*
    [locals]:variable_declaration*
    [statements]:statement*
    [return_expression]:expression;

  variable_declaration =
    [type]:type
    [name]:id;

  formal_parameter =
    [type]:type
    [name]:id;

  type =
    {int}
      [name]:int |
    {int_array}
      [name]:int |
    {boolean}
      [name]:boolean |
    {identifier}
      [name]:id;

  statement =
    {block}
      [statements]:statement* |
    {if}
      [condition]:expression
      [true_statement]:statement
      [false_statement]:statement |
    {while}
      [condition]:expression
      [statement]:statement |
    {println}
      [value]:expression |
    {assign}
      [name]:id
      [value]:expression |
    {array_assign}
      [name]:id
      [index]:expression
      [value]:expression;

  expression =
    {and}
      [left]:expression
      [right]:expression |
    {less_than}
      [left]:expression
      [right]:expression |
    {plus}
      [left]:expression
      [right]:expression |
    {minus}
      [left]:expression
      [right]:expression |
    {negative}
      [value]:expression |
    {times}
      [left]:expression
      [right]:expression |
    {array_lookup}
      [array]:expression
      [index]:expression |
    {array_length}
      [array]:expression |
    {call}
      [instance]:expression
      [name]:id
      [actuals]:expression* |
    {integer}
      [value]:integer_literal |
    {true}
      true |
    {false}
      false |
    {identifier}
      [name]:id |
    {this}
      this |
    {new_array}
      [size]:expression |
    {new_object}
      [class_name]:id |
    {not}
      [expression]:expression;

  id =
    [name]: identifier;
